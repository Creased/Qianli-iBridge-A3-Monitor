<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link
        href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;700&family=Inter:wght@400;600&display=swap"
        rel="stylesheet">
    <title>Qianli Overlay</title>
    <style>
        :root {
            --bg-dark: #0a0a0c;
            --bg-panel: rgba(20, 20, 25, 0.72);
            --bg-elevated: #1e1e24;
            --border-subtle: rgba(255, 255, 255, 0.09);
            --border-medium: rgba(255, 255, 255, 0.18);

            --color-voltage: #00ff55;
            --color-voltage-glow: rgba(0, 255, 85, 0.18);
            --color-voltage-border: rgba(0, 255, 85, 0.28);
            --color-voltage-dim: rgba(0, 255, 85, 0.45);

            --color-current: #ffcc00;
            --color-current-glow: rgba(255, 204, 0, 0.18);
            --color-current-border: rgba(255, 204, 0, 0.28);
            --color-current-dim: rgba(255, 204, 0, 0.45);

            --color-power: #a0a0b0;
            --color-power-border: rgba(160, 160, 176, 0.28);

            --text-main: #ffffff;
            --text-muted: #666680;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html,
        body {
            width: 100%;
            height: 100%;
            background: #0a0a0c;
            overflow: hidden;
            font-family: 'Inter', sans-serif;
        }

        #overlay {
            position: relative;
            width: 100%;
            height: 100%;
        }

        /* ── Scrolling graph ─────────────────────────────────── */
        canvas#graph {
            position: absolute;
            inset: 0;
            width: 100%;
            height: 100%;
            opacity: 0.6;
        }

        /* ── Readings panel ──────────────────────────────────── */
        #readings {
            position: absolute;
            top: 14px;
            left: 14px;
            display: flex;
            flex-direction: column;
            gap: 6px;
            pointer-events: none;
            user-select: none;
        }

        .card {
            display: flex;
            align-items: center;
            gap: 14px;
            padding: 10px 18px 10px 14px;
            border-radius: 10px;
            backdrop-filter: blur(14px);
            -webkit-backdrop-filter: blur(14px);
        }

        .card.v-card {
            background: var(--color-voltage-glow);
            border: 1px solid var(--color-voltage-border);
            box-shadow: 0 0 22px var(--color-voltage-glow);
        }

        .card.i-card {
            background: var(--color-current-glow);
            border: 1px solid var(--color-current-border);
            box-shadow: 0 0 22px var(--color-current-glow);
        }

        .card.w-card {
            background: var(--bg-panel);
            border: 1px solid var(--color-power-border);
        }

        .value {
            font-family: 'JetBrains Mono', 'Consolas', monospace;
            font-size: clamp(48px, 8vw, 130px);
            font-weight: 700;
            letter-spacing: -1px;
            line-height: 1;
        }

        .unit {
            font-family: 'JetBrains Mono', 'Consolas', monospace;
            font-size: clamp(20px, 3vw, 48px);
            font-weight: 400;
            opacity: 0.75;
            align-self: flex-end;
            padding-bottom: 6px;
        }

        .stat {
            font-family: 'JetBrains Mono', 'Consolas', monospace;
            font-size: clamp(10px, 1.1vw, 16px);
            font-weight: 400;
            line-height: 1.8;
            opacity: 0.55;
            margin-left: auto;
            text-align: right;
            align-self: center;
        }

        .v-card .value,
        .v-card .unit {
            color: var(--color-voltage);
        }

        .i-card .value,
        .i-card .unit {
            color: var(--color-current);
        }

        .w-card .value,
        .w-card .unit {
            color: var(--color-power);
        }

        .v-card .stat {
            color: var(--color-voltage-dim);
        }

        .i-card .stat {
            color: var(--color-current-dim);
        }

        /* ── Status badge ────────────────────────────────────── */
        #status {
            position: absolute;
            bottom: 12px;
            right: 16px;
            font-size: 11px;
            font-weight: 600;
            color: var(--text-muted);
            letter-spacing: 0.12em;
            text-transform: uppercase;
            pointer-events: none;
            user-select: none;
            background: var(--bg-panel);
            border: 1px solid var(--border-subtle);
            padding: 4px 10px;
            border-radius: 20px;
            backdrop-filter: blur(8px);
        }

        /* ── Connect overlay ─────────────────────────────────── */
        #connect-wrap {
            position: absolute;
            inset: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(10, 10, 12, 0.55);
            backdrop-filter: blur(6px);
            transition: opacity 0.35s;
        }

        #connect-wrap.hidden {
            opacity: 0;
            pointer-events: none;
        }

        #connect-btn {
            background: var(--bg-panel);
            border: 1px solid var(--border-medium);
            color: var(--text-main);
            font-family: 'Inter', sans-serif;
            font-size: 15px;
            font-weight: 600;
            letter-spacing: 0.08em;
            text-transform: uppercase;
            padding: 14px 44px;
            border-radius: 8px;
            cursor: pointer;
            backdrop-filter: blur(12px);
            transition: background 0.2s, border-color 0.2s;
        }

        #connect-btn:hover {
            background: rgba(255, 255, 255, 0.12);
            border-color: rgba(255, 255, 255, 0.35);
        }
    </style>
</head>

<body>
    <div id="overlay">

        <canvas id="graph"></canvas>

        <div id="readings">
            <div class="card v-card">
                <span class="value" id="val-v">---.---</span>
                <span class="unit">V</span>
                <span class="stat" id="stat-v">Max: ---<br>Min: ---</span>
            </div>
            <div class="card i-card">
                <span class="value" id="val-i">---.---</span>
                <span class="unit">A</span>
                <span class="stat" id="stat-i">Max: ---<br>Min: ---</span>
            </div>
            <div class="card w-card">
                <span class="value" id="val-w">---.---</span>
                <span class="unit">W</span>
            </div>
        </div>

        <div id="status">Disconnected</div>

        <div id="connect-wrap">
            <button id="connect-btn">Connect Device</button>
        </div>
    </div>

    <script>
        // ─── State ────────────────────────────────────────────────────────────────────
        let port = null, reader = null, keepReading = false;
        let histV = [], histI = [];
        const MAX_POINTS = 600;
        let vMax = 0, vMin = 99, iMax = 0, iMin = 99;

        // ─── DOM refs ─────────────────────────────────────────────────────────────────
        const valV = document.getElementById('val-v');
        const valI = document.getElementById('val-i');
        const valW = document.getElementById('val-w');
        const statV = document.getElementById('stat-v');
        const statI = document.getElementById('stat-i');
        const statusEl = document.getElementById('status');
        const connWrap = document.getElementById('connect-wrap');
        const connBtn = document.getElementById('connect-btn');
        const canvas = document.getElementById('graph');
        const ctx = canvas.getContext('2d');

        // ─── Graph ────────────────────────────────────────────────────────────────────
        function resizeCanvas() {
            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;
        }
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        function scaleY(val, maxV, H) {
            if (maxV === 0) return H / 2;
            return H - 8 - (val / maxV) * (H - 16);
        }

        function polyline(hist, color, maxV) {
            if (hist.length < 2) return;
            const W = canvas.width, H = canvas.height;
            const step = W / MAX_POINTS;
            const startX = W - hist.length * step;
            ctx.beginPath();
            ctx.strokeStyle = color;
            ctx.lineWidth = 2;
            ctx.lineJoin = 'round';
            hist.forEach((v, i) => {
                const x = startX + i * step;
                const y = scaleY(v, maxV, H);
                i === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
            });
            ctx.stroke();
        }

        function drawGraph() {
            const W = canvas.width, H = canvas.height;
            ctx.clearRect(0, 0, W, H);
            const topV = Math.max((Math.max(...histV, 0)) * 1.1, 5);
            const topI = Math.max((Math.max(...histI, 0)) * 1.1, 1);
            polyline(histV, '#00ff55', topV);
            polyline(histI, '#ffcc00', topI);
        }

        // ─── Data update ──────────────────────────────────────────────────────────────
        function onSample(v, i) {
            histV.push(v); if (histV.length > MAX_POINTS) histV.shift();
            histI.push(i); if (histI.length > MAX_POINTS) histI.shift();
            if (v > vMax) vMax = v;
            if (v < vMin) vMin = v;
            if (i > iMax) iMax = i;
            if (i < iMin) iMin = i;

            valV.textContent = v.toFixed(3);
            valI.textContent = i.toFixed(3);
            valW.textContent = (v * i).toFixed(3);
            statV.innerHTML = `Max: ${vMax.toFixed(3)}<br>Min: ${vMin.toFixed(3)}`;
            statI.innerHTML = `Max: ${iMax.toFixed(3)}<br>Min: ${iMin.toFixed(3)}`;
            drawGraph();
        }

        // ─── Serial ───────────────────────────────────────────────────────────────────
        connBtn.addEventListener('click', async () => {
            try {
                port = await navigator.serial.requestPort();
                await port.open({ baudRate: 115200 });
                const w = port.writable.getWriter();
                await w.write(new Uint8Array([0xDA, 0x01, 0x00, 0x04, 0x05, 0x00, 0x00, 0x00, 0x00]));
                w.releaseLock();
                // Reset graph and stats for a clean session
                histV = []; histI = [];
                vMax = 0; vMin = 99; iMax = 0; iMin = 99;
                valV.textContent = valI.textContent = valW.textContent = '---.---';
                statV.innerHTML = 'Max: ---<br>Min: ---';
                statI.innerHTML = 'Max: ---<br>Min: ---';
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                connWrap.classList.add('hidden');
                statusEl.textContent = 'Live';
                keepReading = true;
                readLoop();
            } catch (e) { console.error(e); }
        });

        async function readLoop() {
            let buf = new Uint8Array(0);
            while (port.readable && keepReading) {
                reader = port.readable.getReader();
                try {
                    while (true) {
                        const { value, done } = await reader.read();
                        if (done) break;
                        const nb = new Uint8Array(buf.length + value.length);
                        nb.set(buf); nb.set(value, buf.length);
                        buf = nb;
                        while (buf.length >= 8) {
                            if (buf[0] !== 0xDA) { buf = buf.slice(1); continue; }
                            const len = buf[1] | (buf[2] << 8);
                            const total = 8 + len;
                            if (buf.length < total) break;
                            const pkt = buf.slice(0, total);
                            buf = buf.slice(total);
                            const payload = pkt.slice(8);
                            let cs = 0; payload.forEach(b => cs ^= b);
                            if (cs !== pkt[7]) continue;
                            if (pkt[3] === 0x04 && pkt[4] === 0x05 && len === 8) {
                                const dv = new DataView(payload.buffer, payload.byteOffset, 8);
                                onSample(dv.getUint32(4, false) / 1000.0, dv.getUint32(0, false) / 10000.0);
                            }
                        }
                    }
                } catch (e) { console.error(e); }
                finally { reader.releaseLock(); }
            }
            if (port) { await port.close(); port = null; }
            statusEl.textContent = 'Disconnected';
            connWrap.classList.remove('hidden');
        }

        // ─── Idle demo animation ──────────────────────────────────────────────────────
        let _t = 0;
        (function tick() {
            if (!keepReading) {
                _t += 0.04;
                histV.push(5.06 + Math.sin(_t * 0.6) * 0.025);
                histI.push(0.21 + Math.sin(_t * 2.1) * 0.012);
                if (histV.length > MAX_POINTS) histV.shift();
                if (histI.length > MAX_POINTS) histI.shift();
                drawGraph();
            }
            requestAnimationFrame(tick);
        })();
    </script>
</body>

</html>